{
    "ROP Gadget Search - Single Byte": {
        "prefix": "rop",
        "body": [
            "$$ Search for single-byte ROP gadgets (e.g., RET, RETN)",
            ".block",
            "{",
            "\t.for (r \\$t0 = 0x${1:58}; @\\$t0 < 0x${2:5F}; r \\$t0 = \\$t0 + 0x01)",
            "\t{",
            "\t\t.for (r \\$t1 = 0x${3:58}; @\\$t1 < 0x${4:5F}; r \\$t1 = \\$t1 + 0x01)",
            "\t\t{",
            "\t\t\t.if (@@C++(((@\\$t0 != ${5:0x5C}) && (@\\$t1 != ${6:0x5C}))))",
            "\t\t\t{",
            "\t\t\t\ts-[1]b \\${\\$arg1} \\${\\$arg2} \\$t0 \\$t1 ${7:0xC3}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}$0"
        ],
        "description": "Search for ROP gadgets with badchar filtering"
    },
    "ROP Gadget Search - POP RET": {
        "prefix": "gadget_pop",
        "body": [
            "$$ Find POP r32; RET gadgets",
            "s-[1]b ${1:start_addr} ${2:end_addr} ${3:0x58} 0xC3",
            "s-[1]b ${1:start_addr} ${2:end_addr} ${3:0x59} 0xC3",
            "s-[1]b ${1:start_addr} ${2:end_addr} ${3:0x5A} 0xC3",
            "s-[1]b ${1:start_addr} ${2:end_addr} ${3:0x5B} 0xC3",
            "s-[1]b ${1:start_addr} ${2:end_addr} ${3:0x5C} 0xC3",
            "s-[1]b ${1:start_addr} ${2:end_addr} ${3:0x5D} 0xC3",
            "s-[1]b ${1:start_addr} ${2:end_addr} ${3:0x5E} 0xC3",
            "s-[1]b ${1:start_addr} ${2:end_addr} ${3:0x5F} 0xC3$0"
        ],
        "description": "Search for POP reg; RET gadgets"
    },
    "ROP Gadget Search - ADD ESP": {
        "prefix": "gadget_add_esp",
        "body": [
            "$$ Find ADD ESP, value; RET gadgets",
            ".foreach (f {s-[1]b ${1:start_addr} ${2:end_addr} 0x81 0xC4})",
            "{",
            "\tu f L4",
            "}$0"
        ],
        "description": "Search for ADD ESP, imm32; RET gadgets"
    },
    "ROP Gadget Search - JMP REG": {
        "prefix": "gadget_jmp",
        "body": [
            "$$ Find JMP reg / CALL reg gadgets",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE0 $$ JMP EAX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE3 $$ JMP EBX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE1 $$ JMP ECX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE2 $$ JMP EDX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE4 $$ JMP ESP",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE5 $$ JMP EBP",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE6 $$ JMP ESI",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE7 $$ JMP EDI$0"
        ],
        "description": "Search for JMP/CALL register gadgets"
    },
    "Module ASLR Check": {
        "prefix": "aslr",
        "body": [
            "$$ Check ASLR/Rebase for all loaded modules",
            "!for_each_module \".if(wo(dwo(\\${@#Base}+0x3c)+\\${@#Base}+46+18) & 0x40) { .echo \\\"\\${@#ModuleName}: ASLR\\\" } .else { .echo \\\"\\${@#ModuleName}: NO ASLR\\\" }\"$0"
        ],
        "description": "Check which modules have ASLR enabled"
    },
    "Module DEP Check": {
        "prefix": "dep",
        "body": [
            "$$ Check DEP/NX for all loaded modules",
            "!for_each_module \".if(wo(dwo(\\${@#Base}+0x3c)+\\${@#Base}+46+70) & 0x100) { .echo \\\"\\${@#ModuleName}: DEP\\\" } .else { .echo \\\"\\${@#ModuleName}: NO DEP\\\" }\"$0"
        ],
        "description": "Check which modules have DEP enabled"
    },
    "Module SafeSEH Check": {
        "prefix": "safeseh",
        "body": [
            "$$ Check SafeSEH for all loaded modules",
            "!for_each_module \".if(wo(dwo(\\${@#Base}+0x3c)+\\${@#Base}+46+5C) != 0) { .echo \\\"\\${@#ModuleName}: SafeSEH\\\" } .else { .echo \\\"\\${@#ModuleName}: NO SafeSEH\\\" }\"$0"
        ],
        "description": "Check which modules have SafeSEH enabled"
    },
    "Module Full Analysis": {
        "prefix": "modinfo",
        "body": [
            "$$ Full module protection analysis",
            "!for_each_module \".echo \\\"Module: \\${@#ModuleName}\\\"; .echo \\\"Base: \\${@#Base}\\\"; .if(wo(dwo(\\${@#Base}+0x3c)+\\${@#Base}+46+18) & 0x40) { .echo \\\"  ASLR: Yes\\\" } .else { .echo \\\"  ASLR: No\\\" }; .if(wo(dwo(\\${@#Base}+0x3c)+\\${@#Base}+46+70) & 0x100) { .echo \\\"  DEP: Yes\\\" } .else { .echo \\\"  DEP: No\\\" }; .echo \\\"\\\"\"$0"
        ],
        "description": "Comprehensive module protection analysis"
    },
    "Breakpoint on Module Load": {
        "prefix": "bp_load",
        "body": [
            "$$ Break on module load",
            "sxe ld:${1:module_name}",
            "g$0"
        ],
        "description": "Set breakpoint on module load"
    },
    "Conditional Breakpoint": {
        "prefix": "bp_cond",
        "body": [
            "$$ Conditional breakpoint",
            "bp ${1:address} \".if (@${2:register} == ${3:value}) { .echo \\\"Hit!\\\"; } .else { gc; }\"$0"
        ],
        "description": "Breakpoint with condition"
    },
    "Hardware Breakpoint": {
        "prefix": "ba",
        "body": [
            "$$ Hardware breakpoint on access",
            "ba ${1|r,w,e|}${2|1,2,4,8|} ${3:address}$0"
        ],
        "description": "Set hardware breakpoint"
    },
    "Stack Analysis": {
        "prefix": "stack",
        "body": [
            "$$ Analyze stack frame",
            "k",
            "dps @esp L${1:20}",
            "!for_each_frame \"dv\"$0"
        ],
        "description": "Comprehensive stack analysis"
    },
    "Heap Chunk Analysis": {
        "prefix": "heap",
        "body": [
            "$$ Analyze heap chunk",
            "!heap -a ${1:address}",
            "dt _HEAP ${1:address}",
            "!address ${1:address}$0"
        ],
        "description": "Heap chunk and metadata analysis"
    },
    "Find Pattern in Memory": {
        "prefix": "search",
        "body": [
            "$$ Search for byte pattern",
            "s-[1]b ${1:start_addr} ${2:end_addr} ${3:pattern}$0"
        ],
        "description": "Search memory for byte pattern"
    },
    "Find String in Memory": {
        "prefix": "searchstr",
        "body": [
            "$$ Search for string in memory",
            "s-[1]a ${1:start_addr} ${2:end_addr} \"${3:string}\"$0"
        ],
        "description": "Search memory for ASCII string"
    },
    "Find Unicode String": {
        "prefix": "searchuni",
        "body": [
            "$$ Search for Unicode string",
            "s-[1]u ${1:start_addr} ${2:end_addr} \"${3:string}\"$0"
        ],
        "description": "Search memory for Unicode string"
    },
    "Exception Analysis": {
        "prefix": "except",
        "body": [
            "$$ Exception record analysis",
            ".exr -1",
            ".cxr",
            "k",
            "!analyze -v$0"
        ],
        "description": "Analyze exception and context"
    },
    "SEH Chain Dump": {
        "prefix": "seh",
        "body": [
            "$$ Dump SEH chain",
            "!exchain",
            ".foreach (seh {!exchain})",
            "{",
            "\tu poi(seh+4) L2",
            "}$0"
        ],
        "description": "Dump and disassemble SEH handlers"
    },
    "Find Writable Memory": {
        "prefix": "writable",
        "body": [
            "$$ Find writable memory regions",
            "!address -f:PAGE_READWRITE",
            "!address -f:PAGE_EXECUTE_READWRITE$0"
        ],
        "description": "Find writable memory regions"
    },
    "Control Flow Analysis": {
        "prefix": "cfg",
        "body": [
            "$$ Trace control flow",
            "wt -l ${1:1} -oa ${2:address}$0"
        ],
        "description": "Trace control flow from address"
    },
    "Badchar Check Loop": {
        "prefix": "badchar",
        "body": [
            "$$ Check for badchars in address range",
            ".block",
            "{",
            "\tr \\$t0 = ${1:start_addr}",
            "\t.while (@\\$t0 < ${2:end_addr})",
            "\t{",
            "\t\t.if (by(@\\$t0) == ${3:0x00})",
            "\t\t{",
            "\t\t\t.echo \"Badchar at: \"; ? @\\$t0",
            "\t\t}",
            "\t\tr \\$t0 = @\\$t0 + 1",
            "\t}",
            "}$0"
        ],
        "description": "Check for bad characters in memory range"
    },
    "Calculate Distance": {
        "prefix": "distance",
        "body": [
            "$$ Calculate distance between addresses",
            "? ${1:addr2} - ${2:addr1}$0"
        ],
        "description": "Calculate offset between two addresses"
    },
    "Memory Protection": {
        "prefix": "protect",
        "body": [
            "$$ Check memory protection",
            "!address ${1:address}$0"
        ],
        "description": "Display memory protection info"
    },
    "Symbol Resolution": {
        "prefix": "symbol",
        "body": [
            "$$ Resolve symbol or address",
            "ln ${1:address}",
            "x ${2:module}!${3:symbol}$0"
        ],
        "description": "Resolve symbols and addresses"
    },
    "Data Structure": {
        "prefix": "struct",
        "body": [
            "$$ Display structure",
            "dt ${1:module}!${2:structure} ${3:address}$0"
        ],
        "description": "Display data structure"
    },
    "Disassemble Function": {
        "prefix": "func",
        "body": [
            "$$ Disassemble function",
            "uf ${1:address}$0"
        ],
        "description": "Unassemble entire function"
    },
    "Log Analysis Session": {
        "prefix": "log",
        "body": [
            "$$ Start logging session",
            ".logopen ${1:output.log}",
            "${2:commands}",
            ".logclose$0"
        ],
        "description": "Log commands and output to file"
    },
    "Pattern Create": {
        "prefix": "pattern",
        "body": [
            "$$ Generate cyclic pattern (use !pattern_create in mona)",
            ".block",
            "{",
            "\tr \\$t0 = 0",
            "\tr \\$t1 = 0x41414141",
            "\t.while (@\\$t0 < ${1:1000})",
            "\t{",
            "\t\teb @\\$sp+@\\$t0 @\\$t1",
            "\t\tr \\$t1 = @\\$t1 + 0x01010101",
            "\t\tr \\$t0 = @\\$t0 + 4",
            "\t}",
            "}$0"
        ],
        "description": "Generate cyclic pattern for offset finding"
    },
    "Offset Find": {
        "prefix": "offset",
        "body": [
            "$$ Find offset in cyclic pattern",
            "? ${1:value} - 0x41414141$0"
        ],
        "description": "Calculate offset from pattern value"
    },
    "VirtualProtect Setup": {
        "prefix": "vprotect",
        "body": [
            "$$ VirtualProtect() ROP chain helper",
            "$$ kernel32!VirtualProtect: LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect",
            ".echo \"VirtualProtect parameters:\"",
            ".echo \"  lpAddress: ${1:address}\"",
            ".echo \"  dwSize: ${2:0x1000}\"",
            ".echo \"  flNewProtect: 0x40 (PAGE_EXECUTE_READWRITE)\"",
            ".echo \"  lpflOldProtect: ${3:writable_addr}\"$0"
        ],
        "description": "VirtualProtect ROP chain helper"
    },
    "Stack Pivot": {
        "prefix": "pivot",
        "body": [
            "$$ Find stack pivot gadgets",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x94 $$ XCHG EAX,ESP",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x87 0xE0 $$ XCHG ESP,EAX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x8B 0xE0 $$ MOV ESP,EAX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x8B 0x24 0x24 $$ MOV ESP,[ESP]$0"
        ],
        "description": "Search for stack pivot gadgets"
    },
    "Function Hook Detection": {
        "prefix": "hookdet",
        "body": [
            "$$ Detect inline hooks",
            ".foreach (func {x ${1:module}!*})",
            "{",
            "\t.if (by(func) == 0xE9 || by(func) == 0xE8)",
            "\t{",
            "\t\t.echo \"Potential hook at: \"; ln func; u func L5",
            "\t}",
            "}$0"
        ],
        "description": "Detect inline function hooks"
    },
    "IAT Analysis": {
        "prefix": "iat",
        "body": [
            "$$ Analyze Import Address Table",
            "!dh ${1:module} -f",
            "dps ${2:iat_address} L${3:count}$0"
        ],
        "description": "Analyze Import Address Table"
    }
}
