{
    "ROP Gadget Search Loop": {
        "prefix": "rop",
        "body": [
            "$$ Search for two-byte ROP gadgets with badchar filtering",
            "$$ Usage: $$>a< script.wds start_addr end_addr",
            ".block",
            "{",
            "\t.for (r \\$t0 = 0x${1:58}; @\\$t0 < 0x${2:5F}; r \\$t0 = @\\$t0 + 0x01)",
            "\t{",
            "\t\t.for (r \\$t1 = 0x${3:58}; @\\$t1 < 0x${4:5F}; r \\$t1 = @\\$t1 + 0x01)",
            "\t\t{",
            "\t\t\t.if (@@C++(((@\\$t0 != ${5:0x5C}) && (@\\$t1 != ${6:0x5C}))))",
            "\t\t\t{",
            "\t\t\t\ts-[1]b \\${\\$arg1} \\${\\$arg2} @\\$t0 @\\$t1 ${7:0xC3}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}$0"
        ],
        "description": "Search for ROP gadgets with badchar filtering (POP POP RET, etc.)"
    },
    "POP RET Gadgets x86": {
        "prefix": "gadget_pop",
        "body": [
            "$$ Find POP r32, RET gadgets (x86)",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x58 0xC3 $$ POP EAX, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x59 0xC3 $$ POP ECX, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x5A 0xC3 $$ POP EDX, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x5B 0xC3 $$ POP EBX, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x5D 0xC3 $$ POP EBP, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x5E 0xC3 $$ POP ESI, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x5F 0xC3 $$ POP EDI, RET$0"
        ],
        "description": "Search for x86 POP reg, RET gadgets"
    },
    "POP RET Gadgets x64": {
        "prefix": "gadget_pop64",
        "body": [
            "$$ Find POP r64, RET gadgets (x64)",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x58 0xC3 $$ POP RAX, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x59 0xC3 $$ POP RCX, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x5A 0xC3 $$ POP RDX, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x5B 0xC3 $$ POP RBX, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x41 0x58 0xC3 $$ POP R8, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x41 0x59 0xC3 $$ POP R9, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x41 0x5A 0xC3 $$ POP R10, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x41 0x5B 0xC3 $$ POP R11, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x41 0x5C 0xC3 $$ POP R12, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x41 0x5D 0xC3 $$ POP R13, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x41 0x5E 0xC3 $$ POP R14, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x41 0x5F 0xC3 $$ POP R15, RET$0"
        ],
        "description": "Search for x64 POP reg, RET gadgets"
    },
    "ADD ESP Gadgets": {
        "prefix": "gadget_add_esp",
        "body": [
            "$$ Find ADD ESP, imm32 then RET gadgets",
            ".foreach (addr {s-[1]b ${1:start_addr} ${2:end_addr} 0x81 0xC4})",
            "{",
            "\tu addr L4",
            "}$0"
        ],
        "description": "Search for ADD ESP, imm32 gadgets"
    },
    "ADD RSP Gadgets x64": {
        "prefix": "gadget_add_rsp",
        "body": [
            "$$ Find ADD RSP gadgets (x64)",
            ".foreach (addr {s-[1]b ${1:start_addr} ${2:end_addr} 0x48 0x81 0xC4})",
            "{",
            "\tu addr L5",
            "}",
            ".foreach (addr {s-[1]b ${1:start_addr} ${2:end_addr} 0x48 0x83 0xC4})",
            "{",
            "\tu addr L4",
            "}$0"
        ],
        "description": "Search for x64 ADD RSP gadgets"
    },
    "JMP/CALL REG Gadgets": {
        "prefix": "gadget_jmp",
        "body": [
            "$$ Find JMP reg and CALL reg gadgets",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE0 $$ JMP EAX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE3 $$ JMP EBX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE1 $$ JMP ECX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE2 $$ JMP EDX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE4 $$ JMP ESP",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE6 $$ JMP ESI",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xE7 $$ JMP EDI",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xD0 $$ CALL EAX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0xFF 0xD4 $$ CALL ESP$0"
        ],
        "description": "Search for JMP/CALL register gadgets"
    },
    "Stack Pivot Gadgets": {
        "prefix": "pivot",
        "body": [
            "$$ Find stack pivot gadgets",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x94 0xC3 $$ XCHG EAX ESP, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x87 0xE4 0xC3 $$ XCHG ESP EAX, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x8B 0xE0 $$ MOV ESP EAX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x8B 0xE1 $$ MOV ESP ECX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x8B 0xE3 $$ MOV ESP EBX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x5C 0xC3 $$ POP ESP, RET$0"
        ],
        "description": "Search for stack pivot gadgets"
    },
    "Stack Pivot x64": {
        "prefix": "pivot64",
        "body": [
            "$$ Find x64 stack pivot gadgets",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x48 0x94 0xC3 $$ XCHG RAX RSP, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x48 0x87 0xE4 0xC3 $$ XCHG RSP RAX, RET",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x48 0x8B 0xE0 $$ MOV RSP RAX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x48 0x8B 0xE1 $$ MOV RSP RCX",
            "s-[1]b ${1:start_addr} ${2:end_addr} 0x5C 0xC3 $$ POP RSP, RET$0"
        ],
        "description": "Search for x64 stack pivot gadgets"
    },
    "Module ASLR Check x86": {
        "prefix": "aslr",
        "body": [
            "$$ Check ASLR for all loaded modules (x86 PE32)",
            "$$ IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x40",
            "!for_each_module \".if(wo(dwo(\\${@#Base}+0x3c)+\\${@#Base}+0x5E) & 0x40) { .printf \\\"%-20s ASLR: YES\\\\n\\\", \\\"\\${@#ModuleName}\\\" } .else { .printf \\\"%-20s ASLR: NO  ***\\\\n\\\", \\\"\\${@#ModuleName}\\\" }\"$0"
        ],
        "description": "Check which modules have ASLR enabled (x86)"
    },
    "Module ASLR Check x64": {
        "prefix": "aslr64",
        "body": [
            "$$ Check ASLR for all loaded modules (x64 PE32+)",
            "$$ DllCharacteristics at PE + 0x6E for x64",
            "!for_each_module \".if(wo(dwo(\\${@#Base}+0x3c)+\\${@#Base}+0x6E) & 0x40) { .printf \\\"%-20s ASLR: YES\\\\n\\\", \\\"\\${@#ModuleName}\\\" } .else { .printf \\\"%-20s ASLR: NO  ***\\\\n\\\", \\\"\\${@#ModuleName}\\\" }\"$0"
        ],
        "description": "Check which modules have ASLR enabled (x64)"
    },
    "Find Non-ASLR Modules": {
        "prefix": "noaslr",
        "body": [
            "$$ Find modules without ASLR (good for ROP gadgets)",
            ".printf \"\\nModules without ASLR:\\n\"",
            ".printf \"=====================\\n\"",
            "!for_each_module \".if(!(wo(dwo(\\${@#Base}+0x3c)+\\${@#Base}+0x5E) & 0x40)) { .printf \\\"%-20s Base: 0x%p  Size: 0x%x\\\\n\\\", \\\"\\${@#ModuleName}\\\", \\${@#Base}, \\${@#Size} }\"$0"
        ],
        "description": "List all non-ASLR modules for ROP chain building"
    },
    "Module DEP Check": {
        "prefix": "dep",
        "body": [
            "$$ Check DEP/NX compatibility for modules",
            "$$ IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x100",
            "!for_each_module \".if(wo(dwo(\\${@#Base}+0x3c)+\\${@#Base}+0x5E) & 0x100) { .printf \\\"%-20s DEP: YES\\\\n\\\", \\\"\\${@#ModuleName}\\\" } .else { .printf \\\"%-20s DEP: NO  ***\\\\n\\\", \\\"\\${@#ModuleName}\\\" }\"$0"
        ],
        "description": "Check which modules have DEP compatibility"
    },
    "Module SafeSEH Check": {
        "prefix": "safeseh",
        "body": [
            "$$ Check SafeSEH for loaded modules",
            "!for_each_module \".if(dwo(dwo(\\${@#Base}+0x3c)+\\${@#Base}+0xC8) != 0) { .printf \\\"%-20s SafeSEH: YES\\\\n\\\", \\\"\\${@#ModuleName}\\\" } .else { .printf \\\"%-20s SafeSEH: NO  ***\\\\n\\\", \\\"\\${@#ModuleName}\\\" }\"$0"
        ],
        "description": "Check which modules have SafeSEH"
    },
    "Conditional Breakpoint": {
        "prefix": "bp_cond",
        "body": [
            "$$ Conditional breakpoint",
            "bp ${1:address} \".if (@${2:eax} == ${3:0x41414141}) { .echo \\\"Condition hit!\\\" } .else { gc }\"$0"
        ],
        "description": "Breakpoint with condition"
    },
    "Logging Breakpoint": {
        "prefix": "bp_log",
        "body": [
            "$$ Log values and continue",
            "bp ${1:address} \".printf \\\"Hit: EAX=0x%x EBX=0x%x ECX=0x%x\\\\n\\\", @eax, @ebx, @ecx; gc\"$0"
        ],
        "description": "Breakpoint that logs register values and continues"
    },
    "Hardware Breakpoint": {
        "prefix": "ba",
        "body": [
            "$$ Hardware breakpoint",
            "ba ${1|r,w,e|}${2|1,2,4,8|} ${3:address}$0"
        ],
        "description": "Set hardware breakpoint (read/write/execute)"
    },
    "Search Byte Pattern": {
        "prefix": "search",
        "body": [
            "$$ Search for byte pattern",
            "s-[1]b ${1:start_addr} ${2:end_addr} ${3:41 41 41 41}$0"
        ],
        "description": "Search memory for byte pattern"
    },
    "Search ASCII String": {
        "prefix": "searchstr",
        "body": [
            "$$ Search for ASCII string",
            "s-a ${1:start_addr} ${2:end_addr} \"${3:string}\"$0"
        ],
        "description": "Search memory for ASCII string"
    },
    "Search DWORD": {
        "prefix": "searchdword",
        "body": [
            "$$ Search for DWORD value",
            "s-d ${1:start_addr} ${2:end_addr} ${3:0x41414141}$0"
        ],
        "description": "Search memory for DWORD value"
    },
    "Exception Analysis": {
        "prefix": "except",
        "body": [
            "$$ Full exception analysis",
            ".echo \"=== Exception Record ===\"",
            ".exr -1",
            ".echo \"\"",
            ".echo \"=== Context Record ===\"",
            ".cxr",
            ".echo \"\"",
            ".echo \"=== Stack Trace ===\"",
            "k",
            ".echo \"\"",
            "!analyze -v$0"
        ],
        "description": "Analyze current exception"
    },
    "SEH Chain": {
        "prefix": "seh",
        "body": [
            "$$ Dump SEH chain",
            "!exchain$0"
        ],
        "description": "Dump SEH exception handler chain"
    },
    "Find RWX Memory": {
        "prefix": "rwx",
        "body": [
            "$$ Find PAGE_EXECUTE_READWRITE regions",
            "!address -f:PAGE_EXECUTE_READWRITE$0"
        ],
        "description": "Find RWX memory regions"
    },
    "Find Writable Memory": {
        "prefix": "writable",
        "body": [
            "$$ Find writable memory regions",
            "!address -f:PAGE_READWRITE$0"
        ],
        "description": "Find writable memory regions"
    },
    "Badchar Verification": {
        "prefix": "badchar",
        "body": [
            "$$ Verify badchar sequence 0x01-0xFF in buffer",
            ".block",
            "{",
            "\tr \\$t0 = ${1:buffer_addr}",
            "\tr \\$t1 = 0x01",
            "\t.while (@\\$t1 < 0x100)",
            "\t{",
            "\t\t.if (by(@\\$t0) != @\\$t1)",
            "\t\t{",
            "\t\t\t.printf \\\"Badchar: expected 0x%02x at 0x%p, got 0x%02x\\\\n\\\", @\\$t1, @\\$t0, by(@\\$t0)",
            "\t\t}",
            "\t\tr \\$t0 = @\\$t0 + 1",
            "\t\tr \\$t1 = @\\$t1 + 1",
            "\t}",
            "\t.echo \\\"Badchar check complete\\\"",
            "}$0"
        ],
        "description": "Verify 0x01-0xFF badchar sequence in buffer"
    },
    "Calculate Offset": {
        "prefix": "offset",
        "body": [
            "$$ Calculate offset between addresses",
            "? ${1:target_addr} - ${2:source_addr}$0"
        ],
        "description": "Calculate offset between two addresses"
    },
    "Memory Protection": {
        "prefix": "protect",
        "body": [
            "$$ Display memory protection info",
            "!vprot ${1:address}$0"
        ],
        "description": "Display memory protection"
    },
    "Disassemble Function": {
        "prefix": "uf",
        "body": [
            "$$ Disassemble entire function",
            "uf ${1:address}$0"
        ],
        "description": "Unassemble entire function"
    },
    "Stack Dump": {
        "prefix": "stack",
        "body": [
            "$$ Dump stack with symbols",
            "dps @${1|esp,rsp|} L${2:20}$0"
        ],
        "description": "Dump stack pointer-sized values with symbols"
    },
    "VirtualProtect Info": {
        "prefix": "vprotect",
        "body": [
            "$$ VirtualProtect parameters reminder",
            "$$ lpAddress: shellcode location",
            "$$ dwSize: 0x201 or larger", 
            "$$ flNewProtect: 0x40 = PAGE_EXECUTE_READWRITE",
            "$$ lpflOldProtect: writable address",
            "x kernel32!VirtualProtect$0"
        ],
        "description": "VirtualProtect ROP chain helper"
    },
    "Crash Triage": {
        "prefix": "crash",
        "body": [
            "$$ Quick crash triage",
            "r",
            ".exr -1",
            "u @${1|eip,rip|} L3",
            "dps @${2|esp,rsp|} L10",
            "!analyze -v$0"
        ],
        "description": "Quick crash analysis"
    },
    "PEB Info": {
        "prefix": "peb",
        "body": [
            "$$ Display PEB",
            "!peb$0"
        ],
        "description": "Display Process Environment Block"
    },
    "TEB Info": {
        "prefix": "teb",
        "body": [
            "$$ Display TEB",
            "!teb$0"
        ],
        "description": "Display Thread Environment Block"
    },
    "Egg Hunter Search": {
        "prefix": "egg",
        "body": [
            "$$ Search for egg marker (w00tw00t = 0x74303077)",
            "s-d 0 L?80000000 ${1:0x74303077}$0"
        ],
        "description": "Search for egghunter marker"
    },
    "Log Session": {
        "prefix": "log",
        "body": [
            ".logopen ${1:C:\\\\debug.log}",
            "$$ Commands here",
            "$$ .logclose$0"
        ],
        "description": "Start logging session to file"
    }
}
